select poll epoll 都是 IO 多路复用机制。


IO 多路复用机制，即监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。

注意，select poll epoll 本质上都是同步IO，因为他们都需要在读写事件就绪后自己负责进行读写，也就说整个读写过程是阻塞都。



（1）select -> 时间复杂度 O(n)

select 仅仅知道有 IO 事件发生，却并不知道是哪几个流，只能无差别轮询所有流，找出能读出数据或能写入数据的流。然后对他们进行操作。

select 将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态。


（2）poll -> 时间复杂度 O(n)

poll 本质上和 select 类似，但由于内部实现的数据结构不同（基于链表存储），它没有最大连接数的限制。


（3）epoll -> 时间复杂度 O(1)

epoll 可以理解为 event poll，不同于无差别轮询，epoll 通过回调函数的方式通知发生了什么 IO 事件。即 epoll 是事件驱动的。


---



select 有如下几个缺点：

1. 每次调用 select 时都需要把 fd 集合从用户态拷贝到内核态，这个开销在fd很多时会很大；
2. 每次调用 select 都需要在内核遍历传递进来的所有 fd ，这个开销在fd很多时也很大；
3. select 支持的文件描述符数量太小了，默认是1024；

epoll 完全规避了上述缺点。

epoll提供了三个函数
- epoll_create 创建一个epoll句柄；
- epoll_ctl 注册要监听的事件类型；
- epoll_wait 等待事件的产生，用于向用户进程返回就绪列表；

每次调用 epoll_ctl 注册新的事件到 epoll 句柄中时，会把所有的 fd 拷贝进内核，在 epoll_wait 时不需重复拷贝。epoll 保证了每个 fd 在整个过程中只会拷贝一次。

epoll 在调用 epoll_ctl 时为每个 fd 指定了回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调了函数，这个回调函数则会把就绪的 fd 加入一个就绪链表。epoll_wait 的工作实际上就是在这个就绪链表中查看有没有就绪的 fd，睡一会，判断一会。所以是 O(1) 的时间复杂度，避免了 O(n) 的轮询。


epoll 能支持的 fd 数目上限是最大可以打开文件的数目，通常和系统内存关联，具体数目可以通过 cat /proc/sys/fs/file-max 查看。比如在 1GB 内存的机器上大约是 10 万左右。


epoll 的触发方式

https://juejin.cn/post/6844904073276162055

1. 水平触发

    1）对于读操作，只要缓冲内容不为空，LT模式返回读就绪。

    2）对于写操作，只要缓冲区还不满，LT模式会返回写就绪。

    当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。

    如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你。 

    如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。


2. 边缘触发

    1）对于读操作
        
        当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候。

        当有新数据到达时，即缓冲区中的待读数据变多的时候。

        当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLIN事件时。

    2）对于写操作

        当缓冲区由不可写变为可写时。

        当有旧数据被发送走，即缓冲区中的内容变少的时候。

        当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLOUT事件时。

    当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。
    
    如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。
    
    这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。



Q：如何理解 redis 的多路复用？

A：本质是利用事件驱动的 epoll 机制。这里的“多路”指的是多个网络连接，“复用”指的是复用同一个Redis处理线程。当某个 socket 可读或者可写的时候，它可以给你一个通知，只有当系统通知哪个描述符可读了，才去执行read 操作，避免了无谓的轮询消耗。