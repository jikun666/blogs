# redis 实现方案


获取锁

```
set lock_key lock_val_<ip> ex 5 nx
```

解锁

注意，锁的值里面需要有机器标识（比如ip），用于在解锁的时候只能解自己加的锁。

注意，判断加锁者和解锁不是原子操作，所以这里需要用到 redis 脚本（lua）执行该过程。

```
if redis:get(lock_key) == lock_val_<本机ip> then
    redis:del(lock_key) 
else
    return
end
```

上面的锁自动超时还是不优雅，会出现A B 两个进程共同执行业务逻辑，这里可以使用一个守护线程守护A，当快要超时时，给锁续命，防止自动超时，同时当A所在的进程挂掉时，守护现场也挂掉，不会出现永不释放的情况。

有这样一种简化版场景，如果只让某一个行为执行一次，可以使用 incr 命令，只有 incr 返回 1 时才证明是第一次操作。


# zookeeper


redis 的分布式锁不优雅，zookeeper的分布式锁会优雅的多。参考 https://my.oschina.net/u/4543837/blog/4585616

简单来说，zookeeper 使用 临时顺序节点（在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号；当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。）和等待队列实现了分布式锁（想获取锁的客户端挂在一个等待队列中，更像是一个等待链表）。

使用 redis 还是 zk 并不是绝对的，zk性能并不是很高，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能