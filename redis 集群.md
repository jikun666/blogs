集群是 Redis 提供的分布式数据库方案。集群通过分片来进行数据共享，并提供复制和故障转移功能。



## 集群建立

节点启动时会根据 cluster-enabled 配置选项是否为 1 来决定是否开启集群模式。（通过 INFO 命令可查看到 cluster-enabled 选项值）


开机集群模式后，当前节点可通过如下命令连接节点：


```
127.0.0.1:6379> CLUSTER MEET <ip> <port>
```

发送该命令后，节点之间会进行握手，握手成功后，当前节点就会将 ip 和 port 指定的节点添加到 node 节点当前所在的集群中。


发送 CLUSTER NODE 命令可以看到当前集群所有节点。


在节点内部会维护一个 clusterState 的结构体：


```c
#define REDIS_CLUSTER_SLOTS 16384

typedef struct clusterState {
    clusterNode *myself;  /* This node，指向当前节点的指针 */
    uint64_t currentEpoch; /* 集群当前的配置纪元，用于实现故障转移 */
    int state;            /* REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... ，集群当前状态 */
    int size;             /* Num of master nodes with at least one slot */
    dict *nodes;          /* Hash table of name -> clusterNode structures ，节点名—>节点信息 */
    clusterNode *slots[REDIS_CLUSTER_SLOTS]; /* 所有槽对应的节点指针 */

    // ...
} clusterState;
```

nodes 字段是一个字典，key 是节点名， value 是一个 clusterNode 指针，记录了某一个节点的信息。


slots 记录了每个槽对应的 clusterNode 指针，如果某个槽分配给当前节点，myself 指针会出现在这个数组里面。


## 槽指派

集群的整个数据库分为 16384 个槽，数据库中的每个键都属于这个 16384 个槽中的其中一个，集群中的每个节点都可以处理 0 个或最多 16384 个槽。

当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态，否则，集群处于下线状态。

使用 CLUSTER MEET 命令建立集群后，集群并不会自动分配槽，所以集群仍处于下线状态，需手动分配所有槽之后，集群才能算上线状态。

使用 CLUSTER ADDSLOTS 命令进行槽指派。


**记录槽指派信息**


槽指派信息分为两部分存储。

1. 当前节点自身管理了哪些槽，用于 O(1) 时间查询自己管理的槽；
2. 当前集群每个槽由谁管理，用于 O(1) 时间查询任何一个槽由哪个节点管理；


上面的（1）使用位表示：

```c
typedef struct clusterNode {
    unsigned char slots[16384/8]; /* slots handled by this node */
    int numslots; /* 当前节点指派槽的个数 */
} clusterNode;
```

对于 16384 个槽一共用 16384/8 个字节表示所有槽，当前节点管理了那个槽，就把那一位置成 1 ，否则置成 0。


之所以使用位表示，是因为节点的槽指派信息需要在集群中传播，结构体体积越小，越节省网络带宽占用。

当其他的节点收到该结构体时，会更新到自身到 clusterState 中。


即上面的（2）使用一个 clusterNode 指针数组表示：

```c
typedef struct clusterState {
    clusterNode *slots[16384]; /* 所有槽对应的节点指针 */
} clusterState;
```


上面的 slots 数组记录了每个槽由哪个节点管理，当收到其他节点传播过来的槽指派信息时，会进行更新。


注意，上面两种存储结构都是必要的。如果只有（1）没有（2），则无法在任意一个redis节点得知某个槽的管理信息；如果只有（2）没有（1），则无法在 O(1) 时间取到本节点所有管理的槽，即无法将本节点管理的槽信息传播给其他节点。



## 在集群中执行命令

集群中执行命令主要分为 2 步：

1. 计算键属于哪个槽；

    对键进行hash求值得到槽号。

2. 判断槽是否由当前节点负责处理；

    如果不由当前节点处理，节点会返回一个隐式的 MOVED 错误。

    然后自动重定向到正确节点进行处理。返回给客户端的仍是在正确节点中处理的结果。比如


    ```
    127.0.0.1:7000> SET msg "happy new year!"
    -> Redirected to slot [6257] located at 127.0.0.1:7001
    OK

    127.0.0.1:7001>
    ```


## 节点数据库


集群节点保存键值对以及过期时间的方式，与单机模式下完全相同。

区别是集群模式下的节点只能使用 0 号数据库，而单机模式下的节点没有这一限制。

除外，集群中的节点在 clusterState 结构体中维护一个 slots_to_keys 跳跃表来保存**槽**和**键**之间的关系。


slots_to_keys 每个节点的分值（score）是一个**槽号**，成员值（member）是一个**键**。

每当节点往数据库中增加或者删除一个键时，节点都会对 slots_to_keys 进行更新。


slots_to_keys 可以很方便地对属于某个或某些槽对所有数据库**键**进行批量操作。
>例如命令 `CLUSTER GETKEYSINSLOT <slot> <count>` 命令可以返回最多 count 个属于槽 slot 的数据库键，而这个命令就是通过遍历 slots_to_keys 来实现的。


## 重新分片


在集群中加入新节点，然后对新节点进行槽指派，会触发重新分片操作。



重新分片操作将任意数量已经指派给某个节点（源节点）的槽改为指派给另一节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。


重新分片操作可以在线进行，并且源节点和目标节点都可以继续处理命令请求。


**详细过程**
<!-- 当请求处理的键正好在迁移过程中，源节点会返回一个隐藏的 ASK 错误，然后自动转到新的目标节点进行处理。 -->

如果一个节点收到一个关于键 key 的命令请求，并且键 key 所属的槽 i 正好就指派给了这个节点，那么节点会尝试在自己的数据库里查找键 key，如果找到了的话，节点就直接执行客户端发送的命令。

与此相反，如果节点没有在自己的数据库里找到键 key，那么节点会检查 key 所属的槽 i 是否正在进行迁移，如果槽 i 的确在进行迁移的话，那么节点会向客户端发送一个 ASK 错误，引导客户端到正在导入槽 i 的节点去查找键 key；如果没有进行迁移，证明键 key 不存在，源节点执行键不存在的行为。

比如，假设节点 7002 正在向节点 7003 迁移槽 16198，这个槽包含 love 这个键，但是已经被迁移到了 7003，此时向节点 7002 发送关于键 love 的命令，那么客户度会先被转向至节点 7003，然后再次执行命令：

```
127.0.0.1:7002>GET "love"
-> Redirected to slot [16198] located at 127.0.0.1:7003
"you get the key 'love'"

127.0.0.1:7003>
```

和接到 MOVED 错误时的情况类似，集群模式的 redis-cli 在接到 ASK 错误时也不会打印错误，而是自动根据提供的 IP 地址和端口进行转向操作。


## 复制与故障转移

Redis 集群中的节点分为主节点和从节点，主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。


当下线的主节点重新上线后，会成为从节点进行复制。复制的是替代自己成为主节点的那个节点。


哨兵会辅助集群故障转移，在没有哨兵的情况下，集群自己也会故障转移，虽然细节上有很大不同，但集群的实现与哨兵思路类似：通过定时任务发送PING消息检测其他节点状态；节点下线分为主观下线和客观下线；客观下线后选取从节点进行故障转移。