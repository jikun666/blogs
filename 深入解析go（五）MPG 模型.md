对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。线程和进程最大的区别是，进程之间有独立的地址空间，线程与主进程共享地址空间。

协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。
协程是轻量级的线程，它相对线程的优势就在于协程非常轻量级，进行切换以及保存上下文环境代价非常的小。


## 基本概念


Goroutine主要概念如下：
* M（Machine）: 工作线程（OS线程）。
* P（Processor）: 处理器（不是指CPU），包含运行 Go 代码的必要资源，也有调度 goroutine 的能力。
* G（Goroutine）: 即协程，使用关键字 go 创建。


当 M 执行 Go 代码时，它需要关联一个 P，当 M 为 idle 或者在系统调用时，它也需要 P。

M 必须拥有 P 才可以执行 G 中的代码，P含有一个包含多个 G 的队列，P 可以调度 G 交由 M 执行。其关系如下图所示：

![](images/mpg.jpg)


M持有一个P，P将G调度进M中执行。

P同时还维护着一个包含G的队列（图中灰色部分），可以按照一定的策略将G调度到M中执行。


P 的个数默认等同于 CPU 的核数，也可以使用 runtime.GOMAXPROCS() 设置。

由于 M 必须持有一个 P 才可以运行 Go 代码，所以同时运行的 M 个数，也即线程数一般等同于 P 的个数以最大程度利用机器资源。


除了每个 P 维护的 G 队列以外，还有一个全局的队列，每个 P 会周期性地查看全局队列中是否有 G 待运行并将其调度到 M 中执行。

全局队列中G的来源，主要有从系统调用中恢复的G。



## Goroutine 调度策略

1. 队列轮转

    P 周期性的将 G 调度到 M 中执行，执行一小段时间，保存当前上下文，然后将 G 放到队列尾部，然后从队列中重新取出一个 G 进行执行。


2. 系统调用

    当 M 当前的 G 需要进行系统调用时，M 会和 G 一起陷入内核。

    如果检测到干活的数量少于 GOMAXPROCS 并且没有空闲着的 M，则会创建新的 M 来来接管原先的 G 队列并开始运行 G。

    出系统调用的时候，如果已经有 GOMAXPROCS 个 M 在干活了，则这个出系统调用的 M 会被挂起，它的 G 也会被挂到待运行的 goroutine 队列（全局队列）中。

3. 工作量窃取

    每个 P 中维护的 G 队列可能并不均衡，空闲的 P 会窃取其他 P 的 G，一般窃取一半。