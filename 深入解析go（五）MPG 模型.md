对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。线程和进程最大的区别是，进程之间有独立的地址空间，线程与主进程共享地址空间。

协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。
协程是轻量级的线程，它相对线程的优势就在于协程非常轻量级，进行切换以及保存上下文环境代价非常的小。


## 基本概念


Goroutine主要概念如下：
* M（Machine）: 工作线程（OS线程），操作系统直接管辖 M。
* P（Processor）: 处理器（不是指CPU），或叫调度器，包含运行 Go 代码的必要资源，也有调度 goroutine 的能力。
* G（Goroutine）: 即协程，使用关键字 go 创建。


当 M 执行 Go 代码时，它需要关联一个 P，当 M 为 idle 或者在系统调用时，它也需要 P。

M 必须拥有 P 才可以执行 G 中的代码，P含有一个包含多个 G 的队列，P 可以调度 G 交由 M 执行。其关系如下图所示：

![](images/mpg.jpg)


M 持有一个 P，P 将 G 调度进M中执行。G 的眼里只有 P，G 认为是 P 在执行他。而从宏观上来看，真正的 “CPU” 是 M，真正负责接收操作系统调度，放在 CPU 上跑的是 M，只有将 P 与 M 绑定了，才能让 G 队列中的 G 运行起来。

P同时还维护着一个包含G的队列（图中灰色部分），可以按照一定的策略将G调度到M中执行。

真正决定并行度的是 P 的数量。
P 的个数默认等同于 CPU 的核数，也可以使用 runtime.GOMAXPROCS() 设置。

由于 M 必须持有一个 P 才可以运行 Go 代码，所以同时运行的 M 个数，也即线程数一般等同于 P 的个数以最大程度利用机器资源。


除了每个 P 维护的 G 队列以外，还有一个全局的队列，每个 P 会周期性地查看全局队列中是否有 G 待运行并将其调度到 M 中执行。

全局队列中G的来源，主要有从系统调用中恢复的G。

>为什么会有局部队列？只用全局队列可以吗？
>涉及到并发问题，如果只有全局队列，则每一次取G都需要加锁，性能损耗较大。
>本地队列：本地队列是Lock-Free，没有数据竞争问题，无需加锁处理，可以提升处理速度。
>全局队列：全局队列为了保证多个P之间任务的平衡。所有M共享P全局队列，为保证数据竞争问题，需要加锁处理。相比本地队列处理速度要低于全局队列。

>M是偏物理的概念，P是偏逻辑（抽象）的概念。

> M 和 P 是绑定的，但是在某些情况下，P 会被 M 释放
> 
> 当执行 G 任务时有系统调用，当发生系统调用时 M 会处于阻塞状态。调度器会设置一个超时时间，当超时时会将 P 释放。
> 
> 注意，当G因 channel 或者 network I/O 阻塞时，不会阻塞 M，M 会寻找其他 runnable 的 G；当阻塞的 G 恢复后会重新进入 runnable 进入 P 队列等待执行




## Goroutine 调度策略

1. 队列轮转

    P 周期性的将 G 调度到 M 中执行，执行一小段时间，保存当前上下文，然后将 G 放到队列尾部，然后从队列中重新取出一个 G 进行执行。


2. 系统调用

    当 M 当前的 G 需要进行系统调用时，M 会和 G 一起陷入内核。

    如果检测到干活的数量少于 GOMAXPROCS 并且没有空闲着的 M，则会创建新的 M 来来接管原先的 G 队列并开始运行 G。

    出系统调用的时候，如果已经有 GOMAXPROCS 个 M 在干活了，则这个出系统调用的 M 会被挂起，它的 G 也会被挂到待运行的 goroutine 队列（全局队列）中。

3. 工作量窃取

    每个 P 中维护的 G 队列可能并不均衡，空闲的 P 会窃取其他 P 的 G，一般窃取一半。