
Golang 采用标记-清除法（mark-sweep）进行 gc。

## 基本原理

GC 开始时从 root 对象开始扫描，把 root 对象引用的内存标记为“被引用”。注意如果有指针，则指向的对象也要标记。

全部标记完成后，未被标记的内存部分进行清除即完成了回收。

上面用分别用一句话简述了“标记”和“清除”阶段。“标记”阶段会更复杂。采用的是三色标记法。

三色，对应了垃圾回收过程中对象的三种状态：

- 黑色：对象已被标记（该对象在本次 gc 中**不会**被清理）；
- 灰色：对象还在标记队列中等待；
- 白色：对象未被标记（对象在本次 gc 中**会**被清理）。

这里类似于从 root 开始进行宽度搜索，所以需要一个“灰色”队列。

### STW(Stop The World)

Golang 中的 STW 会暂停主进程以及所有的 goroutines，专心做 gc。

STW 时间的长短直接影响了程序性能。所以 golang 针对 STW 进行了优化（写屏障等）。




## 触发时机

1. 自动触发

    1. 内存分配量达到阈值触发 GC。可通过环境变量 GOGC 进行调整。
        
        环境变量 GOGC 的含义是开始 GC 的目标百分比。比如一次回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。
        
        GOGC 不会被默认设置，程序启动的时候如果读不到该设置就认为是 100。

        所以认为是默认内存翻倍触发自动 gc。
    2. 默认情况下，最长2分钟触发一次GC，这个间隔在src/runtime/proc.go:forcegcperiod变量中被声明，无法改变。
        ```
        var forcegcperiod int64 = 2 * 60 * 1e9
        ```

    即内存翻倍或到了2分钟就自动触发 gc。

2. 手动触发

    `runtime.GC()`

## 性能优化

1. 减少对象分配个数，比如复用对象等。

2. 调整 GOGC 参数：下一次 gc 开始的时候的内存使用量。可据此改变 gc 的性能。


## 其他