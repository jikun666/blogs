
Golang 采用标记-清除法（mark-sweep）进行 gc。

>还有引用计数（python）、分代收集（java）方法。

## 基本原理

GC 开始时从 root 对象开始扫描，把 root 对象引用的内存标记为“被引用”。注意如果有指针，则指向的对象也要标记。

全部标记完成后，未被标记的内存部分进行清除即完成了回收。

上面用分别用一句话简述了“标记”和“清除”阶段。“标记”阶段会更复杂。采用的是三色标记法。

三色，对应了垃圾回收过程中对象的三种状态：

- 黑色：对象已被标记（该对象在本次 gc 中**不会**被清理）；
- 灰色：对象还在标记队列中等待；
- 白色：对象未被标记（对象在本次 gc 中**会**被清理）。

这里类似于从 root 开始进行宽度搜索，所以需要一个“灰色”队列。

https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/

1. 所有跟对象标记灰色（所有跟节点放进队列）
2. 从队列中弹出一个标记为黑色，并将其所指向的对象标为灰色（子节点放入队列）；
3. 重复步骤2，知道队列为空

上述标记阶段完成后，所有的对象就分为黑色和白色，白色即需要回收的对象。

注意，用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，需要 STW。


### STW(Stop The World)

Golang 中的 STW 会暂停主进程以及所有的 goroutines，专心做 gc。

STW 时间的长短直接影响了程序性能。所以 golang 针对 STW 进行了优化。

- 写屏障（Write Barrier） - STW的目的是防止GC扫描时内存变化引起的混乱，而写屏障就是让goroutine与GC同时运行的手段，虽然不能完全消除STW，但是可以大大减少 STW 的时间。写屏障在GC的特定时间开启，开启后指针传递时会把指针标记，即本轮不回收，下次GC时再确定。
- 辅助GC（Mutator Assist） - 为了防止内存分配过快，在 GC 执行过程中，mutator 线程会并发运行。

通过线上实测，golang gc 的平均耗时在 1ms 以内（400us以内）。




## 触发时机

1. 自动触发

    1. 内存分配量达到阈值触发 GC。可通过环境变量 GOGC 进行调整。
        
        环境变量 GOGC 的含义是开始 GC 的目标百分比。比如一次回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。
        
        GOGC 不会被默认设置，程序启动的时候如果读不到该设置就认为是 100。

        所以认为是默认内存翻倍触发自动 gc。
    2. 默认情况下，最长2分钟触发一次GC，这个间隔在src/runtime/proc.go:forcegcperiod变量中被声明，无法改变。
        ```
        var forcegcperiod int64 = 2 * 60 * 1e9
        ```

    即内存翻倍或到了2分钟就自动触发 gc。

2. 手动触发

    `runtime.GC()`

## 性能优化

1. 减少对象分配个数，比如复用对象等。

2. 调整 GOGC 参数：下一次 gc 开始的时候的内存使用量。可据此改变 gc 的性能。
