# SQL 语句执行顺序

- (7) SELECT
- (1) FROM
- (2) JOIN
- (3) ON
- (4) WHERE
- (5) GROUP BY
- (6) HAVING
- (8) ORDER BY
- (9) LIMIT


# 索引


**InnoDB 索引为什么使用B+树？**
1. B+tree的磁盘读写代价更低

    B+树除了叶子节点不存储实际数据值，同样大小的内存能够存储更多的索引节点，可减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适

2. B+tree的查询效率更加稳定

    任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，所以每一个数据的查询效率相当，因此B+树相比B树更为合适

3. 范围查询方便
   
    B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低
    
**B+树的叶子节点放的什么？**

可以存储整行数据，也有可以存储主键的值。

存储了整行数据的是主键索引，也被称之为聚簇索引；存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。

聚簇索引查询会更快：因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，可能还需要再通过主键的值再进行一次查询，(这个过程叫回表)。

注意，非主键索引如果实现了索引覆盖（覆盖索引，查询的字段已经在索引中了），则不用回表。比如下面的sql（表中有索引 name,id_card 的联合索引）：


```sql
select SQL_NO_CACHE count(name) from index_test where name = '小明' and id_card = '142701199999999999';
```

**布尔值需要加索引吗？**

不需要，即使加了也可能会失效。

给bool型加索引区分度是2，加了可能也是要走全表扫描的。也就是说加了索引带来写性能的下降和存储空间的增大，但对读性能提升没什么帮助。还不如不加。


**索引失效的情况？**
1. 使用 <> 或 != 符号。比如

```sql
SELECT * FROM `t_index` WHERE key1 <> '1';
```

2. 查询条件类型不一致。比如 key 为字符串

```sql
SELECT * FROM `t_index` WHERE key1 = 1;
```

3. 查询条件使用函数计算

```
SELECT * FROM `t_index` WHERE key1 + 1 = 1;
SELECT * FROM `t_index` WHERE CHAR_LENGTH(key1) = 1;
```

4. 模糊查询

```sql
SELECT * FROM `t_index` WHERE key1 LIKE  '3';
SELECT * FROM `t_index` WHERE key1 LIKE  '%3';
SELECT * FROM `t_index` WHERE key1 LIKE  '3%';
```

5. 不使用索引首列当查询条件

在字段 key1, key2, key3 上创建复合索引：

```sql
DROP INDEX idx_key1 ON `t_index`;
ALTER TABLE `t_index` ADD INDEX idx_key123(key1, key2, key3);
```


如下查询会失效：

```sql
SELECT * FROM `t_index` WHERE key2 = '2' AND key3 = '3';
SELECT * FROM `t_index` WHERE key2 = '2';
SELECT * FROM `t_index` WHERE key3 = '3';
```


# 数据类型


**整数**

TINYINT SMALLINT MEDIUMINT INT BIGINT

上述这些选择决定 mysql 怎么在内存和磁盘保存数据，然后计算一般是使用 64 位的BIGINT 整数，即使在 32 位环境也是如此。


mysql 还可以为整数类型指定宽度，
>例如 INT(11) 对大多数应用这是没有意义的：他不会限制值的合法范围，只是规定了 mysql 的一些交互工具（例如 mysql 命令行客户端）用来显式字符的个数。


**实数**

实数是带有小数部分的数字。

FLOAT 和 DOUBLE 类型支持使用标准的浮点运算进行近似计算。

DECIMAL 类型用于存储精确的小数。

浮点类型（FLOAT、DOUBLE）在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。

FLOAT 使用 4 个字节存储，DOUBLE 占用 8 个字节，相比 FLOAT 有更高的精度和更大的范围。

和整数类型一样，对浮点类型来说，能选择的只是存储类型，计算统一使用 DOUBLE。

因为需要额外的空间和计算开销，应该尽量只在对小数进行精确计算时才使用 DECIMAL，例如财务存储。
>数据量较大时，考虑使用 BIGINT 代替 DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。这样可同时避免浮点精度问题和DECIMAL计算开销大的问题。

**字符串**

VARCHAR

需要使用 1 或 2 个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用 2 个字节。
>假设采用 latin1 字符集，一个 VARCHAR(10) 的列需要11个字节的存储空间，VARCHAR(1000）的列则需要1002个字节，因为需要2个字节存储长度信息。

以下情况使用 VARCHAR 是合适的：
- 字符串列的最大长度比平均长度大很多；
- 列的更新很少，所以碎片不是问题；
- 使用了像 UTF-8 这样复杂的字符集，每个字符都使用不同的字节数进行存储。



CHAR

MySQL 总是根据定义的字符串长度分配足够的空间。当存储 CHAR 值时，MySQL 会删除所有的末尾空格。

Char 适合存储很短的字符串，或者所有值都接近同一个长度。例如，MD5 值，因为这是一个定长的值。

对于经常变更的数据，CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不容易产生碎片。

对于非常短的列，CHAR 比 VARCHAR 在存储空间上也更有效率。
>例如用 CHAR(1) 来存储 Y 和 N 的值，如果采用单字节字符集，只需要一个字节，但是 VARCHAR(1) 却需要两个字节，因为还有一个记录长度的额外字节。

# 查询优化

**索引优化**

1. 可通过慢查询日志定位耗时长的 SQL 语句或者未命中索引的 SQL 语句等问题
1. 通过 explain 查询和分析 SQL 的执行计划
  
**库表结构优化**

1. 按照三大范式设计库表结构
1. 水平扩展（sharding）

# 事务


事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。


ACID 特征：
* 原子性(Atomicity) 事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚；
* 一致性(Consistency) 事务的执行结果必须使数据库从一个正确的状态到另一个正确的状态，正确的状态即当前的状态满足预定的约束就叫做正确的状态，举例转账（一致性理解较困难，参见 https://www.zhihu.com/question/31346392 ）；
* 隔离性(Isolation) 并发执行的事务之间不能相互影响；
    > 隔离级别：隔离级别决定了一个 session 中的事务可能对另一个 session 中的事务的影响。ANSI标准定义了 4 个隔离级别从低到高，MySQL的InnoDB都支持。
    >
    > MySQL 默认是**可重复读级别**，保证了在同一个事务中多次读取同样的记录的结果是一致的。但是可重复读仍然有幻读的问题。即当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会看见这一行，称为“幻行”。
    >
    > InnoDB通过多版本并发控制解决了幻读的问题。
* 持久性(Durability) 事务一旦提交，对数据库中数据的改变是永久性的；

---

四种隔离级别（参考 https://blog.csdn.net/u010960184/article/details/82557978）：

1. 读未提交（Read Uncommitted)

    会出现脏读问题。

    事务t1可能读到事务t2未提交的内容。即 t1 可能读到 t2 更新后的值，虽然 t2 还未提交。



1. 读已提交（Read Committed）

    会出现不可重复读问题。

    事务t1多次读的过程中读取到的记录不同，即记录可能被其他事务改变。


1. 可重复读（Repeatable Read）

    引入“行锁”才解决的不可重复读问题。

    会出现幻读问题。

    事务t1多次读的过程中，可能会看到新插入的记录，成为“幻行”。InnoDB 通过 MVCC 解决该问题。

    注意 InnoDB 有“行锁”的存在，所以设计时需考虑。

1. 可串型化（Serializable）


    终极解决方案。

    引入“表锁”才解决幻读问题。

    通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。

    在这个级别，可能导致大量的超时现象和锁竞争。


以上 4 中级别，级别越高，效率越低。

---





## MySQL 常见日志

https://www.cnblogs.com/myseries/p/10728533.html

**重做日志（redo log)**

确保事务的持久性。redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。


**回滚日志（undo log）**

保证数据的原子性，保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。

**二进制日志（binlog)**

用于复制，在主从复制中，从库利用主库上的 binlog 进行重播，实现主从同步。

用于数据库的基于时间点的还原。

**中继日志（relaylog）**

用于主从复制中的从节点，主节点将binlog写入本地，从节点定时请求增量binlog，从节点的一个单独进程会将 binlog 拷贝至本地 relaylog 中。从节点定时重放 relaylog。

**错误日志（errorlog）**

记录在启动、运行或停止 mysqld 时遇到的问题；

**通用查询日志（general log）**

记录了服务器接收到的每一个查询或是命令，无论这些查询或是命令是否正确甚至是否包含语法错误，general log 都会将其记录下来。

也正因为mysql服务器需要不断地记录日志，开启General log会产生不小的系统开销。 因此，Mysql默认是把General log关闭的。

**慢查询日志（slow log)**


慢日志记录执行时间过长（超过 long_query_time）和没有使用索引的查询语句



## 事务和存储引擎相关

MySQL 提供了两种是事务型的存储引擎，InnoDB 和 NDB Cluster。注意 MyISAM 引擎是非事务型引擎。

MySQL 默认采用自动提交方式。

InnoDB 是 MySQL 的默认事务型引擎，也是最重要、使用最广泛的存储引擎。如无特别的原因要使用其他的存储引擎，都应优先使用 InnoDB 引擎。

InnoDB 采用 MVCC(多版本并发控制技术) 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是可重复读，并且通过间隙锁策略防止幻读的出现。


InnoDB 实现了行锁，行锁只在存储引擎实现，不在 MySQL 服务器层实现。可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。

**MVCC 的实现**

https://blog.csdn.net/chen77716/article/details/6742128

通过保存数据在某个时间点的快照实现的。也即是说，不管需要执行多长时间，每个事务看到的数据都是一致的。


Innodb为每行记录都实现了两个个隐藏字段：1）事务ID 2）回滚指针 。
6字节的事物ID用来标识该行所述的事务，7字节的回滚指标识Innodb的事务模型。

事务以排他锁（互斥锁，读写锁）的形式修改原始数据，把修改前的数据存放于undo log，通过回滚指针与主数据关联。

Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。


# 线上分库

如何实现线上服务的分库分表？（如何实现线上服务的rehash？）

https://www.w3cschool.cn/architectroad/architectroad-level-split-database.html


分为垂直切分、水平切分。

**垂直切分**

将不同的属性拆分到不同到表中。

将长度较短、访问频率较高的属性尽量放在一个表里（主表），将字段较长、访问频率较低的属性尽量防在另一个表里（扩展表），并且查询时尽量不要使用 join 查询，避免主表和扩展表耦合在一个数据库实例上。

Q: 为什么要根据长度、访问频率分主表和扩展表？

A: 数据库会以行为单位 load 进自身的进程缓存（磁盘->内存），行的长度越短、访问频率越高，就越能缓存更多的行、提升缓存命中率。


**水平切分**


根据主键划分到不同到库表。


划分方法通常分为范围法（range）和哈希法（hash）。

范围法缺点比较明显，请求量不均，可能某一个库表的访问频率很高，分担压力的效果可能会变差。


哈希法效果较好，但是缺点是扩容麻烦，扩容后的数据查询也会更麻烦。

Q1: 扩容后，如何查找非主键的记录？

A: 暴力方法是遍历所有库，不可取。解法1）建立非主键和主键的映射表，缺点是多一次查询，性能减半；解法2）构造非主键和主键的函数关系，通过非主键可以本地直接得到对应主键，难点是需要构造映射函数；解法3）构造非主键和对应库的函数关系，与解法2类似


Q2: 如何实现平滑扩容（不停机）？

A: 使用双主架构，服务重启后，再改成单主架构，再增加新的双主同步，保证高可用，最后可以删除冗余数据。[参考](https://www.w3cschool.cn/architectroad/architectroad-database-smooth-expansion.html)。
